---
title: "SelfConsistentPrior"
output: html_document
---

```{r setup, include=FALSE}
# install.packages("remotes")
remotes::install_github("stan-dev/cmdstanr")
library(cmdstanr)
library(rstan)
library(dplyr)
library(tidyverse)
library(reshape)
library(parallel)
library(bayesplot)
library(posterior)
devtools::install_github("hyunjimoon/SBC")
library(SBC)
set.seed(1954)
.libPaths("~/Rlib")
source("tools/selfCalib.R")
source("tools/functions.r")
options(mc.cores = parallel::detectCores())
```

# 1. normal model with mean parameter with distribution
```{R}
tv = c("theta") # target variable that determines iteration termination condition
modelName = "simple_normal"
modDir <- set_get_Dir(modelName)$modDir
delivDir <- set_get_Dir(modelName)$delivDir
file <- set_get_Dir(modelName)$file
mod_simple_normal = cmdstanr::cmdstan_model(file)
n_prival = 20 # the number of generated parameter values for each dataset
n_dataval = 8 # the number of generated data values for each dataset
n_sample = 4000 # the number of posterior samples for each dataset (nchains * ndraws)

generator_priorvals_simple <- function(true_params, n_dataval, predictor = NULL){
  y <- rvar_rng(rnorm, n = n_dataval, mean = true_params$theta)
  nd <- ndraws(true_params)
  theta_loc <- rvar(rep(mean(true_params$theta), nd))
  theta_scale <- rvar(rep(sd(true_params$theta) ,nd))
  gen_rvars <- draws_rvars(y = y, theta_loc = theta_loc, theta_scale = theta_scale, D = n_dataval)
  SBC_datasets(
    parameters = as_draws_matrix(true_params),
    generated = draws_rvars_to_standata(gen_rvars)
  )
}
datasets_simple <- generator_priorvals_simple(draws_rvars(theta = rvar_rng(rnorm, 1, mean = 3, sd = 4, ndraws = n_prival)), n_dataval) 
backend_simple <- SBC_backend_cmdstan_sample(mod_simple_normal)
result_simple <- compute_results(datasets_simple, backend_simple)
priors <- as_draws_rvars(subset_draws(datasets_simple$parameters, variable = tv))

#target calibration
evolve_df <- list()
evolve_df[[tv]] <- list(median = rep(NA,1), sd = rep(NA,1))
predictor = NULL 
sc_priors <- selfCalib(priors, predictor, generator_priorvals_simple, mod_simple_normal, tv, n_dataval, n_sample, cnt = 1, evolve_df, delivDir)
# test self-consistency for sc_prior
sc_datasets_simple <- generator_priorvals_simple(sc_priors, n_dataval) 
sc_result_simple <- compute_results(sc_datasets_simple, backend_simple) 
# before after compare with ecdf and rank summary
# graphical inspection
g <- plot_ecdf_diff(result_simple)
sc_g <- plot_ecdf_diff(sc_result_simple)
ggsave(g, file =  file.path(delivDir, paste0(paste0(paste0(var, "_"), "bfCalib_ecdf.png"), sep = "")))
ggsave(sc_g, file =  file.path(delivDir, paste0(paste0(paste0(var, "_"), "afCalib_ecdf.png"), sep = "")))
# numeric inspection
priors_next <- post2pri(priors, result_simple, tv, sumtype = "prior2prior_filtering") 
sc_priors_next <- post2pri(sc_priors, sc_result_simple, tv, sumtype = "prior2prior_filtering")
self_cons_msr_bfcalib <- set2set(priors, priors_next, "theta")                                                
self_cons_msr_afcalib <- set2set(sc_priors, sc_priors_next, "theta")
csv_save(list(before = self_cons_msr_bfcalib, after = self_cons_msr_afcalib), delivDir, type = "diagnositcs")
```
Both numerical and graphical ecdf indicate that `sc_g` is better calibrated than `g`.

## 2. sgmd model
### 2.1.sgmd model1 with different data region; x = rnorm(20, [0, 5], 2) 
With zero mean for x, datasets from all `prior_width` are good. Generator input consists of true parameter point values `ture_priorvals` and `predictor`. Note the difference in plural and singular. Compared to parameters which has variability between each prior values (rvar<n_priorval>[1], e.g.0.026 ± 0.99), predictor's variability exist only within one datasets. All dataset from each priorpoint have the same value of predictor (rvar<1>[n_priorval]), e.g. 1.4724 ± NA).
```{R sgmd1 with 1/(1+exp^(-wx + b))}
modelName = "sigmoid"
delivDir <- set_get_Dir(modelName)$delivDir
file <- set_get_Dir(modelName)$file
mod_sgmd = cmdstanr::cmdstan_model(file)
n_priorval = 200
n_dataval = 1
n_sample = 4000
generator_priorvals_sgmd <- function(true_params, predictor, n_dataval){
  n_priorval = ndraws(true_params)
  x = predictor$x 
  sigma = rvar(rep(0.1, n_priorval))
  w = true_params$w 
  b = true_params$b
  y_true = 1 / (1 + exp(-w*x-b))
  prior_width = 10
  y <- rvar_rng(rnorm, n = n_priorval, mean = y_true, ndraws = n_dataval) 
  gen_rvars <- draws_rvars(N = n_priorval, x = x, y = y, prior_width = prior_width, sigma = sigma)
  SBC_datasets(
    parameters = as_draws_matrix(true_params), 
    generated = draws_rvars_to_standata(gen_rvars)
  )
}

backend_sgmd <- SBC_backend_cmdstan_sample(mod_sgmd)
datasets_sgmd_x0 <- generator_priorvals_sgmd(true_params = draws_rvars(w = rvar(rnorm(n_priorval, 0, 1)), b = rvar(rnorm(n_priorval, 0, 1))), predictor = draws_rvars(x = rvar_rng(rnorm, n_priorval, 0, 2,ndraws = 1)), n_dataval)
result_x0 <- compute_results(datasets_sgmd_x0, backend_sgmd)
plot_ecdf_diff(result_x0, K = 10)

fit_sgmd_divergent_rstan <- sampling(rstan::stan_model(file = set_get_Dir(modelName)$file), data = datasets_sgmd_x0$generated[[1]])
pairs(fit_sgmd_divergent_rstan, pars = "energy__", include = FALSE)
```

Different data region with the same likelihood and prior distribution can be divergent. Although the calibration was good with $x \sim N(0,2^2)$ and without any divergence, both SBC ecdf_diff and pairs plot returns bad result for the dataspace corresponding to predictor $x \sim norm(5,2)$ with the same likelihood and prior distribution.
```{R, sgmd1 with norm(5,2) dataset}
set.seed(2000)
datasets_sgmd_x5_init <- generator_priorvals_sgmd(true_params = draws_rvars(w = rvar(rnorm(n_priorval, 0, 1)), b = rvar(rnorm(n_priorval, 0, 1))), predictor = draws_rvars(x = rvar_rng(rnorm, n_priorval, 5, 2, ndraws = 1)), n_dataval)
result_sgmd_x5_init <- compute_results(datasets_sgmd_x5_init, backend_sgmd)
plot_ecdf_diff(result_sgmd_x5_init)
fit_sgmd_divergent <- sampling(rstan::stan_model(file = set_get_Dir(modelName)$file),
                                        data = datasets_sgmd_loc5_init$generated[[1]])
pairs(fit_sgmd_divergent, pars = "energy__", include = FALSE)
```

Would changing the `prior width` mitigate the problem? From 10 to 1 or 30? It turns out wider prior width leads to greater divergence.
```{R}
set.seed(1954)
generator_priorvals_sgmd_w <- function(true_params, predictor, n_dataval, priorwidth){
  n_priorval = ndraws(true_params)
  x = predictor$x 
  sigma = rvar(rep(0.1, n_priorval))
  w = true_params$w 
  b = true_params$b
  y_true = 1 / (1 + exp(-w*x-b))
  prior_width = priorwidth
  y <- rvar_rng(rnorm, n = n_priorval, mean = y_true, ndraws = n_dataval)
  gen_rvars <- draws_rvars(N = n_priorval, x = x, y = y, prior_width = prior_width, sigma = sigma)
  SBC_datasets(
    parameters = as_draws_matrix(true_params), 
    generated = draws_rvars_to_standata(gen_rvars)
  )
}
datasets_sgmd_x5_w1 <- generator_priorvals_sgmd_w(true_params = draws_rvars(w = rvar(rnorm(n_priorval, 0, 1)), b = rvar(rnorm(n_priorval, 0, 1))), predictor = draws_rvars(x = rvar_rng(rnorm, n_priorval, 5, 2,)), n_dataval, 1)
datasets_sgmd_x5_w30 <- generator_priorvals_sgmd_w(true_params = draws_rvars(w = rvar(rnorm(n_priorval, 0, 1)), b = rvar(rnorm(n_priorval, 0, 1))),  predictor = draws_rvars(x = rvar_rng(rnorm, n_priorval, 5, 2,)), n_dataval, 30)
result_sgmd_x5_w1 <- compute_results(datasets_sgmd_x5_w1, backend_sgmd)
result_sgmd_x5_w30 <- compute_results(datasets_sgmd_x5_w30, backend_sgmd)
plot_ecdf_diff(result_sgmd_x5_w1)
plot_ecdf_diff(result_sgmd_x5_w30)

fit_sgmd_divergent_w1 <- sampling(rstan::stan_model(file = set_get_Dir(modelName)$file), data = datasets_sgmd_x5_w1$generated[[1]])
pairs(fit_sgmd_divergent_w1, pars = "energy__", include = FALSE)

fit_sgmd_divergent_w30 <- sampling(rstan::stan_model(file = set_get_Dir(modelName)$file), data = datasets_sgmd_loc5$generated[[1]])
pairs(fit_sgmd_divergent_w30, pars = "energy__", include = FALSE)
```

Can self-calibration drive the initial prior to a well-calibrated parameter space i.e. auto-calibrated? It seems for this example, the current implementation fo prior
```{R sigmoid auto-calib}
set.seed(2000)
# target calibration
tv = c("w","b")
priors_sgmd_init <- as_draws_rvars(subset_draws(datasets_sgmd_x5_init$parameters, variable = tv))
evolve_df <- list()
for (v in tv){evolve_df[[v]] <- list(median = rep(NA,1), sd = rep(NA,1))}
predictor <- draws_rvars(x = rvar_rng(rnorm, n_priorval, 5, 2, ndraws = 1))
priors_sgmd_sc <- selfCalib(priors_sgmd_init, predictor, generator_priorvals_sgmd, mod_sgmd, tv, n_dataval, n_sample, cnt = 1, evolve_df, delivDir)
datasets_sgmd_sc <- generator_priorvals_sgmd(priors_sgmd_sc, predictor,n_dataval) 
result_sgmd_x5_sc <- compute_results(datasets_sgmd_sc, backend_sgmd)

# before after compare with graphical and numerical summary
g <- plot_ecdf_diff(result_sgmd_x5_init)
sc_g <- plot_ecdf_diff(result_sgmd_x5_sc)
ggsave(g, file =  file.path(delivDir, "bfCalib_ecdf.png"))
ggsave(sc_g, file = file.path(delivDir, "afCalib_ecdf.png"))

# numeric inspection
priors_next <- post2pri(priors, result_sgmd_x5_sc, "w", sumtype = "post2prior_reweight") 
priors_next_sc <- post2pri(priors_sgmd_sc, result_sgmd_x5_sc, tv, sumtype = "post2prior_reweight")
self_cons_msr_bfcalib <- list()
self_cons_msr_afcalib <- list()
self_cons_msr_bfcalib["w"] <- set2set(priors, priors_next, "w")
self_cons_msr_bfcalib["b"] <- set2set(priors, priors_next, "b")
self_cons_msr_afcalib["w"] <- set2set(priors_sgmd_sc, priors_next_sc, "w")
self_cons_msr_afcalib["b"] <- set2set(priors_sgmd_sc, priors_next_sc, "b")
csv_save(list(before = self_cons_msr_bfcalib, after = self_cons_msr_afcalib), delivDir, type = "diagnositcs")
```
