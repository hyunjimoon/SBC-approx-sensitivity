nChains <- 4
parallel_chains <- min(nChains, detectCores())
M = 20
N = 20

loc_scale_post <- function(post_theta){
  return (list("loc" = t(apply(post_theta, c(2), median)), "scale" = t(apply(post_theta, c(2), sd))))
}

selfCalib <- function(modelName, sbc_obj, prior_theta, par_names, N, M, data, cnt){
  delivDir <- set_get_Dir(modelName)$delivDir
  prior_out = loc_scale_post(prior_theta) # sample summary for stan input
  data$param_loc = prior_out$loc
  data$param_scale = prior_out$scale
  sampled_y = sbc_obj$sample_y_tilde(prior_theta, data=data)
  post_theta = sbc_obj$sample_theta_bar_y(sampled_y, data=data, pars=par_names, fit_iter=M)
  NMP_tb <- as_tibble(post_theta)
  NMP_G <- NMP_tb %>%  gather(variable)
  NMP_G$par <- gsub("\\..*","",NMP_G$variable)
  NMP_G$prior <- sapply(NMP_G$variable, function(x){prior_theta[as.integer(gsub(".*\\.","",x)), gsub("\\..*","",x)]})
  postVar <- NMP_G %>% group_by(par) %>% summarise('postVar'  = sd(value)^2)

  priVar = NMP_G %>% select(prior, par)  %>% group_by(par) %>% unique() %>% summarise('priVar' = sd(prior)^2)
  ratioVar = inner_join(postVar, priVar) %>% summarise("ratioVar" =postVar/priVar)

  #summarize NM posterior samples to N for each parameter
  s_post_theta = NMP_G %>% group_by(par, variable) %>% summarise('median'  = round(median(value),3)) %>% select(par, median)
  #as.matrix(s_post_theta %>% pivot_wider(names_from = par, values_from =mean)) #%>% summarise('mean'  = round(mean(value),3))
  
  #plot post by prior
  NMP_G  %>% group_by(par, prior) %>% summarise("post_median" = median(value)) %>%
    ggplot(aes(x = prior, y = post_median, colour = par))  + geom_point() + xlim(min(prior_theta), max(prior_theta)) + ylim(min(prior_theta), max(prior_theta)) + coord_equal()
  
  medVarRatio <- round(median(ratioVar$ratioVar), 2)
  if(any(ratioVar$ratioVar<0.9) || any(ratioVar$ratioVar > 1.1)){
    cnt = cnt +1
    return (iter_gen_inf(modelName, sbc_obj, summarize_post(post_theta), par_names, N, M, data, cnt))
  }
  else{
    return (post_theta)
  }
}

# run `iter_gen_inf`
model_cp = cmdstanr::cmdstan_model("tests/eightschools_cp.stan") # code below
sbc_obj_cp = SBC::SBCModel$new(name="eightschools_cp", stan_model=model_cp)
modelName <- "8s"
par_names <- list("theta", "mu", "tau")
J <- 8
y <- c(28, 8, -3, 7, -1, 1, 18, 12)
sigma <- c(15, 10, 16, 11, 9, 11, 10, 18)
data = list("J"=J, "y"=y, "sigma"=sigma)
prior_theta_cp = sbc_obj_cp$sample_theta_tilde_stan(par_names, N, data=data) # partial pars possible
sc_prior_8s  <- selfCalib(modelName, sbc_obj_cp, prior_theta_cp, par_names, N, M, data, cnt =0)

```
data {
  int <lower=0> J; // number of schools
  real y[J]; // estimated treatment
  real<lower=0> sigma[J]; // std of estimated effect
}
parameters {
  real theta[J]; // treatment effect in school j
  real mu; // hyper-parameter of mean
  real<lower=0> tau; // hyper-parameter of sdv
}
model {
  tau ~ cauchy(0, 5); // a non-informative prior
  theta ~ normal(mu, tau);
  y ~ normal(theta, sigma);
  mu ~ normal(0, 5);
}
generated quantities {
  vector[J] y_;
  vector[J] theta_;
  real mu_;
  real tau_;
  mu_ = normal_rng(0, 5);
  tau_ = fabs(cauchy_rng(0, 5));
  for(j in 1:J){
    y_[j] = normal_rng(theta[j], sigma[j]);
    theta_[j] = normal_rng(mu_, tau_);
  }
}
```
